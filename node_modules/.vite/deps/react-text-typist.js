import {
  require_jsx_runtime
} from "./chunk-D3IRTNH5.js";
import {
  require_react
} from "./chunk-N7R36T7K.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/react-text-typist/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
function ___$insertStyle(css) {
  if (!css || typeof window === "undefined") {
    return;
  }
  const style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css;
  document.head.appendChild(style);
  return css;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
___$insertStyle("@keyframes blink {\n  50% {\n    opacity: 1;\n  }\n}");
var Typer = function(_a) {
  var sentences = _a.sentences, _b = _a.startDelay, startDelay = _b === void 0 ? 0 : _b, _c = _a.cursorDelay, cursorDelay = _c === void 0 ? startDelay : _c, _d = _a.className, className = _d === void 0 ? "" : _d, _e = _a.cursorClassName, cursorClassName = _e === void 0 ? "" : _e, _f = _a.cursorColor, cursorColor = _f === void 0 ? "" : _f, _g = _a.cursorBlinkSpeed, cursorBlinkSpeed = _g === void 0 ? 700 : _g, _h = _a.showCursor, showCursor = _h === void 0 ? true : _h, _j = _a.hideCursorOnFinish, hideCursorOnFinish = _j === void 0 ? false : _j, _k = _a.cursorSmooth, cursorSmooth = _k === void 0 ? false : _k, _l = _a.typingSpeed, typingSpeed = _l === void 0 ? 80 : _l, _m = _a.deletingSpeed, deletingSpeed = _m === void 0 ? 30 : _m, _o = _a.pauseTime, pauseTime = _o === void 0 ? 1e3 : _o, _p = _a.loop, loop = _p === void 0 ? true : _p, _q = _a.style, style = _q === void 0 ? {} : _q, _r = _a.defaultText, defaultText = _r === void 0 ? "" : _r, _s = _a.onTypeFinish, onTypeFinish = _s === void 0 ? function() {
  } : _s;
  var _t = (0, import_react.useState)(defaultText), text = _t[0], setText = _t[1];
  var _u = (0, import_react.useState)(false), isDeleting = _u[0], setIsDeleting = _u[1];
  var _v = (0, import_react.useState)(0), loopNum = _v[0], setLoopNum = _v[1];
  var _w = (0, import_react.useState)(typingSpeed), writingSpeed = _w[0], setWritingSpeed = _w[1];
  var mountedRef = (0, import_react.useRef)(false);
  var refText = (0, import_react.useRef)(text);
  var refIsDeleting = (0, import_react.useRef)(isDeleting);
  var refLoopNum = (0, import_react.useRef)(loopNum);
  var refWritingSpeed = (0, import_react.useRef)(writingSpeed);
  var refTimer = (0, import_react.useRef)(0);
  var timer1 = (0, import_react.useRef)(0);
  var timer2 = (0, import_react.useRef)(0);
  var timer3 = (0, import_react.useRef)(0);
  var refIsGoingToDelete = (0, import_react.useRef)(false);
  var refIsFinished = (0, import_react.useRef)(false);
  refText.current = text;
  refIsDeleting.current = isDeleting;
  refLoopNum.current = loopNum;
  refWritingSpeed.current = writingSpeed;
  (0, import_react.useEffect)(function() {
    mountedRef.current = true;
    return function() {
      mountedRef.current = false;
      clearTimeout(refTimer.current);
      clearTimeout(timer1.current);
      clearTimeout(timer2.current);
      clearTimeout(timer3.current);
    };
  }, []);
  var handleType = (0, import_react.useCallback)(function() {
    var i = refLoopNum.current % sentences.length;
    var fullText = sentences[i];
    setText(refIsDeleting.current ? fullText.substring(0, refText.current.length - 1) : fullText.substring(0, refText.current.length + 1));
    if (!refIsDeleting.current && refText.current === fullText && !refIsGoingToDelete.current) {
      refIsGoingToDelete.current = true;
      timer1.current = window.setTimeout(function() {
        setIsDeleting(true);
        setWritingSpeed(deletingSpeed);
        refIsGoingToDelete.current = false;
      }, pauseTime);
    } else if (refIsDeleting.current && refText.current === "") {
      setIsDeleting(false);
      setWritingSpeed(typingSpeed);
      setLoopNum(refLoopNum.current + 1);
    }
    if (loop || i !== sentences.length - 1 || refText.current.length !== fullText.length) {
      if (refIsGoingToDelete.current) {
        timer2.current = window.setTimeout(function() {
          refTimer.current = window.setTimeout(handleType, refWritingSpeed.current);
        }, pauseTime);
      } else {
        refTimer.current = window.setTimeout(handleType, refWritingSpeed.current);
      }
    } else {
      refIsFinished.current = true;
      onTypeFinish();
    }
  }, [deletingSpeed, loop, pauseTime, typingSpeed, sentences, onTypeFinish]);
  (0, import_react.useEffect)(function() {
    timer3.current = window.setTimeout(function() {
      if (!mountedRef.current) {
        return;
      }
      handleType();
    }, startDelay);
  }, [handleType, startDelay]);
  var styledSpan = (0, import_react.useMemo)(function() {
    return {
      opacity: 0,
      visibility: showCursor ? "visible" : "hidden",
      color: cursorColor,
      animation: "blink ".concat(cursorBlinkSpeed, "ms ").concat(cursorSmooth ? "" : "steps(1)", " infinite"),
      animationDelay: "".concat(cursorDelay, "ms")
    };
  }, [cursorBlinkSpeed, cursorColor, cursorDelay, cursorSmooth, showCursor]);
  return (0, import_jsx_runtime.jsxs)("span", __assign({ style }, { children: [(0, import_jsx_runtime.jsx)("span", __assign({ className }, { children: text })), !(refIsFinished.current && hideCursorOnFinish) && (0, import_jsx_runtime.jsx)("span", __assign({ className: "typist-cursor ".concat("".concat(cursorClassName, " ").concat(className)), style: styledSpan }, { children: "|" }))] }));
};
export {
  Typer as default
};
//# sourceMappingURL=react-text-typist.js.map
